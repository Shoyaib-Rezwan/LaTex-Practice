\section{Design Process \& Goals}
We conducted an iterative user-centered design process to create MACEDON. The design process included three key stages: 1) Understanding \& Ideation—involving an interview study with experienced programmers to uncover challenges and strategies in code optimization using LLM-driven tools; 2) Prototype \& Walkthrough—the design and development of MACEDON, informed by the insights gained, followed by a cognitive walkthrough for feedback and iterative refinements; 3) Deploy \& Evaluate—a user study to assess how programmers interact with the system and its perceived usefulness 
in streamlining code optimization. In this section, we describe the first stage of our design process, outlining the strategies and design goals that guided the development of MACEDON.

\subsection{Interview Process}
We recruited six participants (4 males, 2 females; ages 20 to 27, $M=23.5$, $SD=1.2$) with different levels of programming experiences through purposive sampling for our interviews.  A pre-test survey screened for eligibility using a 5-point scale for experience, total years in the field, and self-reported use of AI tools. The group included three novice programmers with approximately one year of experience and two with at least five years. Overall, participants were well-versed in programming ($M = 4.17$, $SD = 0.41$) and frequently utilized LLMs for optimization ($M = 7.5$, $SD = 2.10$ times/week). They provided informed consent and received 20 CAD for a 60-minute session.To encourage reflection on optimization strategies, participants shared recent examples of ChatGPT usage prior to the study. During the 60-minute sessions, researchers conducted interviews exploring the challenges of evaluating code states, translating those evaluations into further optimizations, and identifying specific user needs. All sessions were audio-recorded and transcribed for analysis. The team performed thematic analysis \cite{terry2017thematic} using both inductive and deductive methods. Following two iterations of analysis and the resolution of disagreements through discussion, the researchers identified and categorized the final key themes and participant strategies.

\subsection{Interview Results}
Here, we present our findings on the workflows that participants adopted during the code optimization process and the challenges they encountered. 

\subsubsection{Multi-Dimensional Code Evaluation}
Participants' code optimization involved two primary phases: assessing the current code state across dimensions like clarity and efficiency to identify shortcomings, and then implementing specific improvements. However, a lack of transparency in recommendations often made it difficult to determine if changes improved performance or merely increased complexity. As P4 noted, distinguishing between actual optimization and added complexity is a significant hurdle. To manage this cognitive load, all participants adopted a strategy of breaking the optimization process into smaller, manageable steps.

All six participants indicated that a structured, multi-dimensional approach would increase efficiency. While some prioritized time efficiency and documentation, others admitted to overlooking space usage and redundancy until prompted by external feedback. P2 and P6 highlighted that issues like space efficiency or code redundancy often go unnoticed unless specifically flagged or until others struggle to read the code. These observations suggest that a systematic, multi-dimensional evaluation framework is necessary to ensure code optimization is both organized and comprehensive.

\subsubsection{Facilitating Direct Code Segment Optimization}
Participants struggled with managing large volumes of code, often feeling a loss of control during the optimization process. This led to a strong preference for optimizing \textit{``dimension by dimension,''} as noted by P2. The majority of participants (4/6) expressed frustration when systems applied changes to the entire codebase simultaneously. Instead, they preferred the direct manipulation of specific segments based on individual priorities, such as time performance or clarity. P5 highlighted that fixing one section at a time helps in understanding exactly what changes are being made and why.

To address these difficulties, most participants (4/6) utilized a strategy of optimizing self-contained segments independently before merging them back into the larger codebase. This modular approach allowed users like P4 to see improvements gradually. Another common method involved targeting specific code segments based on data from previous runs to avoid unintended effects on other sections. However, this process remains tedious; P5 noted the significant effort required to track, preserve, and compare optimized versions against the original code while ensuring no conflicts arise within the rest of the system.

\subsubsection{Real-Time Feedback for Iterative Code Optimization}
Every participant expressed frustration with the constant switching between code evaluation and applying optimizations, which frequently caused cognitive overload. P2 shared, \textit{``Sometimes I need to stop and evaluate if the optimization worked; it breaks my flow and makes the whole process slower.''} P5 agreed, noting it was \textit{``frustrating to go back and forth between evaluation and deciding whether to make changes.''} Despite these challenges, participants favored real-time feedback to quickly verify \textit{``whether the code change is accurate,''} as stated by P4.

Many participants highlighted the advantages of performing iterative optimization on small, individual code segments. P4 explained, \textit{``I often focus on the areas that require the most attention first and do iterative prompting until it works.''} This iterative approach to refining specific sections allowed users to maintain control over the development process. By focusing on targeted adjustments rather than broad changes, they ensured that each modification remained strictly aligned with their overall optimization goals without negatively impacting the entire codebase.

\subsection{Design Guidelines}
Based on the interview results, we derived the following design guidelines to drive the development of MACEDON. 
\begin{enumerate}[label={\textbf{DG\arabic*:}}]
    \item \textbf{Providing Multi-Dimensional Feedback for Code Evaluation.} A lack of comprehensive evaluation across different metrics can prevent programmers from fully understanding the state of their code. The system should offer multi-dimensional feedback,such as performance, readability, and clarity, to help users better understand the strengths and weaknesses of their code. This evaluation should be presented in a structured and organized manner, allowing programmers to externalize their thought processes and refine specific areas of the code based on the feedback. Flexible feedback options should reflect the various dimensions programmers need for code optimization. 
    \item \textbf{Facilitating Direct Code Segment Optimization.} Programmers often feel a loss of control when working with large amounts of code that require detailed optimization. The system should support direct manipulation of specific code segments, enabling users to select and modify areas for improvement based on their priorities. It should also allow programmers to reorganize or refine their code incrementally, providing the ability to test and apply optimization recommendations to one segment at a time, instead of overwhelming them with global code changes. 
    \item \textbf{Integrating Real-Time and Interative Code Evaluation with Optimization Suggestions.}  Programmers often face cognitive overload due to the constant need to switch between code evaluation and applying optimizations. The system should integrate real-time feedback with iterative suggestions, allowing programmers to continuously assess their code and apply optimizations without disrupting their workflow. By providing timely, contextual feedback during the optimization process, the system can guide users in refining their code in a smooth, iterative manner. 
\end{enumerate}
